REGULAR EXPRESSIONS

WHAT IS A REGULAR EXPRESSION

A way to describe a pattern in a string 
Used to compare, find matches
A string is a kind of regex that only matches exact duplicates






MATCHING SPECIFIC CHARACTERS

A parser compares each character in a regular expression with a character in the
string in the same position

The regex parser requires two things: An expression (or pattern) and a string to
match

? matches the character that appears directly before it zero times or one time

[] Character set: exactly one of the characters in the set will match one
position in the string. Allows you to place an upper and lower case letter and
match both






MATCHING CHARACTER RANGES

Can put a character or numerical range [A-Za-z] inside of a character set






USING WILDCARD CHARACTERS

\ usually means the character that follows has a special meaning. can also be
used for escaping (escaping normal bx, or treating a character as normal which
is usually special)

\d is [0-9] (digit)

\w is [A-Za-z0-9_] used for matching "word characters" where _ is used when a
space cannot be used

\s is [ \t\r\n\f] to match white space characters (space, tab, some line return
characters)

. is any character






FINDING REPEATED CHARACTERS

* zero or more

ex: toy\w* there needs to be zero or more word characters that follow toy (toy,
toyboat, or toycar all match)

+ one or more

ex: toy\w+ there needs to be one or more word characters that follow toy
(toyboat and toycar match, toy does not)

{} allows a certain number of repetitions

{3,} allows 3 or more repetitions

{3,5} allows 3-5 repetitions






EXCLUDING CHARACTERS

[^] negated character set ([^@.] excludes the @ symbol and .) good for comma
separated values

\D not digit

\W not word

\S not whitespace






ALTERNATION

|

Alternation is like the "or" operator in javascript. It tells the parser to
either match one pattern or another. instead of two pipe characters its just
one.

Naturally groups the expressions that it separates






GROUPS

() groups parts of expressions together






BEGINNING AND ENDING OF STRINGS

Only consider something a match if the entire string fits our pattern, reject
partial matches

^ beginning of string

$ end of string














REGULAR EXPRESSIONS IN PRACTICE: VALIDATING A FORM

WHAT IS VALIDATION

process to guard against getting bad or inaccurate data - makes sure data
follows the pattern we're expecting

to use in javascript with literal syntax: /regexpString/

ex: const regexObject = /^word$/ //this stores a regular expression object in
the variable named regexObject


to use in js with the regular expression constructor: new RegExp(regexpString)
this is useful when dynamically creating regex, like when a user enters text
into a search bar

ex: const regexObject = new RegExp("^word$")

JS holds regular expressions in special objects that can be used a number of
ways






USING REGULAR EXPRESSIONS IN JAVASCRIPT

regex.test(testString) lets you check to see if a string matches the pattern
you've defined in a regular expression, returns true or false

string.replace(regex, replacementString) returns new string modified to your
specifications (replaces regex with replacement string)

ex: const regex = /^corn/ const string1 = 'corndog' string1.replace(regex,
'hot') "hotdog" //the regex matches part of string1, that part is replaced with
the replacement string "hot"






FLAGS

Flags in regular expressions modify the way the expression behaves. / overrides
a default behavior of regular expressions

i case-insensitive

g global (by default, regex stops searching once it finds a match. this tells
the parser to find all matches contained in a string)

m multiline (normally a carrot will only match the very beginning of a string,
and a dollar sign will only match the end. any line breaks the string contains
will be considered part of the string. this causes the parser to treat line
breaks like new lines. a carrot will match the beginning of each new line and a
dollar sign will match the end)

to add these flags to a regex in js, put them after the last slash of a regex
literal

/regex/igm






VALIDATING A USERNAME

// Can only contain letters a-z in lowercase

function isValidUsername(username) {
  return /^[a-z]+$/.test(username)
}

//.test() returns true or false. ^ and $ are used to make it so username is only
considered a match if the entire string fits our pattern, reject partial
matches. Without this, .test() would return true so long as username contained
any lowercase letters






VALIDATING A PASSWORD

// Must contain a lowercase, uppercase letter and a number

function isValidPassword(password) {
  return /[a-z]/.test(password) && 
         /[A-Z]/.test(password) && /[0-9]/.test(password);
}

//since we did not include ^ and $, this regex allows partial matches. So if the
password contains at least one lowercase AND at least one uppercase AND at least
one number, this will return true






VALIDATING A PHONE NUMBER

// The telephone number must be in the format of (555) 555-5555

function isValidTelephone(telephone) {
  return /^\(\d\d\d\) \d\d\d-\d\d\d\d$/.test(telephone)
}


OR

function isValidTelephone(telephone) {
  return /^\(\d{3}\)\s\d{3}-\d{4}$/.test(telephone)
}

//parentheses are special characters so they need an escape character \ before
them






VALIDATING AN EMAIL

lots of ways to do this, disagreement among developers

// Must be a valid email address

function isValidEmail(email) {
  return /^[^@]+@[^@.]+\.[a-z]+$/i.test(email)
}

//if email has at least one character that is not the @ symbol, then @, then at
least one character that is not @ or ., then ., and then at least one letter,
all of which is case insensitive, returns true















REFORMATTING USER INPUT

USING REPLACE WITH CAPTURED GROUPS

() can be used to create a group which is treated like a single character. ()
also captures the contents within it. Those contense can be accessed by $1 $2 $3
etc, left to right.

ex:

let string = 'abc' string.replace(/(\w)(\w)(\w)/, '$3 $2 $1') >"c b a"

ex:

string = "5337" let regex = /(\d*)(\d{2})/ let replacement = '$$$1.$2'
string.replace(regex, replacement) >$53.37

//regex first group is zero or more digits, second group is 2 digits - allows us
to target the last 2 digits in order to put a decimal before them. In
replacement value, double dollar sign is interpreted as a literal dollar sign.






A BETTER TELEPHONE NUMBER VALIDATOR

^\D*\d{3}\D*\d{3}\D*\d{4}\D*$

//this says zero or more characters that are not a digit, then 3 digits, 0+ not
digits, 3 digits, 0+ not digits, 4 digits, and then 0+ not digits //this allows
users to add formatting or unnecessary spaces




 

REFORMATTING A TELEPHONE NUMBER

ex:

function formatTelephone(text) {
  const regex = /^\D*(\d{3})\D*(\d{3})\D*(\d{4})\D*$/ return text.replace(regex,
  '($1) $2-$3');
}

//regex is the same as in the previous example, except with 3 groupings. The
.replace() method is called on the string "text", replaces the regex match (in
this case the entire string) with the first group in parentheses, a space, the
second group, a dash, and the third group.


telephoneInput.addEventListener("blur", e => {
  e.target.value = formatTelephone(e.target.value)
});

//when the telephoneInput element loses focus, its value is reformatted














const usernameInput = document.getElementById("username"); const passwordInput =
document.getElementById("password"); const telephoneInput =
document.getElementById("telephone"); const emailInput =
document.getElementById("email");

/** * * VALIDATORS * */

// Can only contain letters a-z in lowercase function isValidUsername(username)
{
  return /^[a-z]+$/.test(username)
}

// Must contain a lowercase, uppercase letter and a number function
isValidPassword(password) {
  return /[a-z]/.test(password) && 
         /[A-Z]/.test(password) && /[0-9]/.test(password);
}

// The telephone number must be in the format of (555) 555-5555 function
isValidTelephone(telephone) {
  return /^\D*\d{3}\D*\d{3}\D*\d{4}\D*$/.test(telephone)
}

// Must be a valid email address function isValidEmail(email) {
  return /^[^@]+@[^@.]+\.[a-z]+$/i.test(email)
}

/** * * FORMATTING FUNCTIONS * */

function formatTelephone(text) {
  const regex = /^\D*(\d{3})\D*(\d{3})\D*(\d{4})\D*$/ return text.replace(regex,
  '($1) $2-$3');
}

/** * * SET UP EVENTS * */

function showOrHideTip(show, element) {
  // show element when show is true, hide when false if (show) {
    element.style.display = "inherit";
  } else {
    element.style.display = "none";
  }
}

function createListener(validator) {
  return e => {
    const text = e.target.value; const valid = validator(text); const showTip =
    text !== "" && !valid; const tooltip = e.target.nextElementSibling;
    showOrHideTip(showTip, tooltip);
  };
}

usernameInput.addEventListener("input", createListener(isValidUsername));

passwordInput.addEventListener("input", createListener(isValidPassword));

telephoneInput.addEventListener("input", createListener(isValidTelephone));

telephoneInput.addEventListener("blur", e => {
  e.target.value = formatTelephone(e.target.value)
});

emailInput.addEventListener("input", createListener(isValidEmail));











.after for project 3 isvalid
