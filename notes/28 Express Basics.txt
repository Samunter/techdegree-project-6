GETTING STARTED WITH EXPRESS

WHAT IS EXPRESS?

A web application framework for node.js

a web framework is a set of software tools to create dynamic web applications






INSTALL EXPRESS

in terminal:

mkdir <folder> to create a folder

cd <folder/> to change to this folder

npm init -y to create package.js with defaults

npm install express --save to install express locally

code <file> to create a new file and open in vs code

in app.js:

const express = require('express');






CREATING A SERVER IN EXPRESS

.listen() makes a server on your computer so you can access files from your computer via the browser. pass an argument of a port number. optional callback argument

app.listen(3000);

in the terminal, run your file and a server will be set up

node app.js






CREATING A ROUTE WITH EXPRESS

a route is just like a url, it's the path a user takes to access data on a server. a route (end point) is a command to the application to run a specific function

.get() is used to handle the get requests to a certain url. first parameter is the location (route), second is the callback that runs when the client requests this route.

.send() sends its argument to the client - a string, html...

you will need to restart the server from the terminal (ctrl + C, node app.js) every time you make a change unless you install nodemone

npm install -g nodemon

to use this make sure that your package.json file's "main" property is set to your entry point for your project (app.js in this case)



app.get('/', (request, response) => {
  response.send('I love treehouse!');
});






ADDING MULTIPLE ROUTES TO THE APP

To have a message print to the terminal when the server restarts, add a callback argument to .listen()

app.listen(3000, () => {
  console.log('The application is running on localhost:3000!');
});

to add another branch, add another .get() method

app.get('/hello', (req, res) => {
  res.send('<h1>Hello, JavaScript developer!</h1>');
});
















USING TEMPLATES WITH EXPRESS

WHAT IS TEMPLATE RENDERING?

Templates are special type of file that have their own syntax and language. They live on the server and act as some kind of form letter for your HTML






WHAT IS PUG?

A language that compiles or translates to html.instead of using opening and closing tags, you just type the tag name, a space, and then the content. to nest, you use indentation

pug:

html(lang="en")
  head
  body
    div(class="wrapper") OR .wrapper for short
      div(id="mainContent) Hi! OR #mainContent Hi!

html:

<html lang="en">
  <head>
  </head>
  <body>
    <div class="wrapper">
      <div id="mainContent">Hi!</div>
    </div>
  </body>
</html>






USING PUG IN YOUR EXPRESS APP

1) download Pug with npm

npm install pug --save


2) update code in app to use Pug

app.set('view engine', 'pug');

the app.set() method defines different settings in Express. This line tells express which template engine to use. by default, express will look in a folder called Views in the root of your project. If you want to name your folder something else, or nest it into another folder, you'll need to define the view setting and point Express to the right place.


3) create templates

index.pug within the views folder is the template that will render when the user visits the root url

doctype html
html(lang="en")
  head
    title Landing Page
  body
    h1 The future home of something magical!
    p Gate wind, moonshine horses meow irrigation , with


4) render templates with response.render()

replace res.send() with res.render('index')

You don't need the file extension because you already set the view engine to pug, so express knows to look for files with the pug extension






EXPRESS'S RESPONSE.RENDER METHOD

you render a variable by using = after the tag

h1= variable

response.render() takes in two optional parameters in addition to the view parameter. the second parameter is an object whose properties are locals, or variables we want the view to have access to when its being rendered.

app.get('/cards', (req, res) => {
  res.render('card', {prompt: "Who is buried in Grant's tomb?"});
});

alternatively, you can set locals by added properties to res.locals

app.get('/cards', (req, res) => {
  res.locals.prompt = "Who is buried in Grant's tomb?";
  res.render('card');
});


to interpolate variables in pug, #{variableName}. This doesn't work for attributes - you'll have to concatenate strings with any variables, or use template literals

h1 Hi my name is #{name}

h1(title="My name is " + name)

h1(title=`My name is ${name}`)






USING LOGIC IN PUG

if/else:
        if hint
             p
                i Hint: #{hint}
        else 
          p (There is no hint.)

loop:
      ul
        each color in colors
          li= color






BREAKING YOUR PROJECT'S TEMPLATES INTO PARTIALS

code that is reused across templates should be contained in one file.

bits that may get complicated can be separated into their own files within their own folder called "includes". these are called partials

LAYOUT.PUG

doctype html
html(lang="en")
  head
    title Flashcards
  body
    include includes/header.pug
    block content
    include includes/footer.pug


INDEX.PUG

extends layout.pug

block content
  section#content
    h2 Welcome, student!


VIEWS/INCLUDES/FOOTER.PUG

footer
    p An app to help you study
















DEEPER INTO ROUTING WITH EXPRESS

POST REQUESTS

HELLO.PUG

extends layout

block content
    h2 Welcome, student!
    form(action='/hello', method='post')
        label Please enter your name:
            input(type='text', name='username')
        button(type='submit') Submit


APP.JS

app.get('/hello', (req, res) => {
  res.render('hello');
});

app.post('/hello', (req, res) => {
  res.render('hello');
});

// Form takes 2 arguments, the path the form posts to, and the http action.
// You need a get() method to render the page, and a post() method to send the data. This just reloads the form because we haven't programmed what to do with the submitted data.




 

THE REQUEST OBJECT

https://expressjs.com/en/4x/api.html#req

the request object is a javascript bundle of data from the incoming http request

req.body is where our form response will end up. By default it is undefined. To put our form responses into the body. we'll need what is called Middleware. Middleware is basically some code that fits in the middle of a request or a response. It does something to the incoming data and hands the result off to the rest of your application.

we need to install a middleware parser
npm install body-parser --save

Body-parser contains several parses, the different ways the clients can send data. html forms normally encode the data they send the same way urls do, so we'll need to use the url encode parser.

APP.JS

const bodyParser = require('body-parser');

app.use(bodyParser.urlencoded({ extended: false }));




THE RESPONSE OBJECT

https://expressjs.com/en/4x/api.html#res

offers ways to shape the response back to the client

.send() sends a response string (object, html, json, etc)

.render() merges data with templates to serve dynamic pages

.json() serves data


APP.JS

app.post('/hello', (req, res) => {
  res.render('hello', { name: req.body.username });
});

// save name as a local


HELLO.PUG

extends layout

block content
    if name
        h2 Welcome, #{name}!
    else
        form(action='/hello', method='post')
            label Please enter your name:
                input(type='text', name='username')
            button(type='submit') Submit
// if name is defined, welcome <name> is displayed and the form is hidden
// if name is undefined, welcome <name> is hidden and the form is displayed






STATELESSNESS, SETTING AND READING COOKIES

http is called a stateless protocol - the server doesn't track the relationship between one request and another. each transaction with a server is independent and unrelated from the server's perspective. eg, forms don't retain the "state" between refreshes by default.

cookies are encoded with info by the server. the browser sends the encoded cookie along with every request it makes.

set cookie name and value with res.cookie()
https://expressjs.com/en/4x/api.html#res.cookie
res.cookie(name, value [, options])
APP.JS
app.post('/hello', (req, res) => {
  res.cookie('username', req.body.username);
  res.render('hello', { name: req.body.username });
});
//This will send a cookie to the browser after we submit the form


We need another piece of middleware to read the cookies, called cookie-parser
npm install cookie-parser --save

read cookies with req.cookies()
https://expressjs.com/en/4x/api.html#req.cookies
APP.JS
const cookieParser = require('cookie-parser');
app.use(cookieParser());
app.get('/hello', (req, res) => {
  res.render('hello', { name: req.cookies.username });
});
// the server can read the cookie that is sent with the get request, and display that info






REDIRECTS

https://expressjs.com/en/api.html#res.redirect

can call res.redirect() instead of res.render(), passing a url

app.post('/hello', (req, res) => {
  res.cookie('username', req.body.username);
  res.redirect('/');
});
// redirects users to the homepage when they submit the form






CHALLENGES: REDIRECTS

app.get('/', (req, res) => {
  const name = req.cookies.username;
  if (name) {
    res.render('index', { name: name });
  } else {
    res.redirect('/hello');
  }
});
// if name is undefined (no encoded cookie), redirect to hello page. otherwise, render home page, which displays the name.


app.get('/hello', (req, res) => {
  const name = req.cookies.username;
  if (name) {
    res.redirect('/');
  } else {
    res.render('hello');
  }
});
// if name is set, redirect to homepage. otherwise, display the hello page and it's form as usual.






SOLUTION: CLEARING COOKIES AND REDIRECTING

index.pug:

extends layout.pug

block content
  section#content
    h2 Welcome, #{name}!
    form(action='/goodbye', method='post')
      button(type='submit') Goodbye
// form posts to /goodbye


app.js:

app.post('/goodbye', (req, res) => {
  res.clearCookie('username');
  res.redirect('/hello');
});
// when posting to goodbye, we clear the cookie and redirect to /hello
















MIDDLEWARE

WHAT IS EXPRESS MIDDLEWARE?

(req, res, next) => {}

next triggers the Middleware function after the current one to execute

to run middleware in response to requests, pass it into app.use
app.use((req, res, next) => {});
this will run the middleware function after every request

to only run it for a specific route, pass the router argument in before the middleware function
app.use('/users', (req, res, next) => {});

you can also limit the middleware to only use get requests.
app.get('/users', (req, res, next) => {});






MIDDLEWARE SEQUENCE AND ROUTING

app.use((req, res, next) => {
  req.message = 'This message made it!';
  next();
});

app.use((req, res, next) => {
  console.log(req.message);
  next();
});

// On every request, the first middleware function modifies the request object, and the second middleware function can access the new req.message property and log it to the console.

can also pass multiple functions

app.use((req, res, next) => {
  console.log('one');
  next();
},
{
  console.log('two');
  next();
});

modifying the request object is a lot of what gives middleware its power. allowing us to gather and compute data and send it back to the client. bodyparser for example creates a body property on the request object, and then we can use that to respond to the client.






THE 'NEXT' FUNCTION AND A CLOSER LOOK AT MIDDLEWARE

next signals the end of middleware functions. another way to signal the end is by sending a response to the client.






HANDLING ERRORS IN AN EXPRESS APP

You can use the next() function to signal an error in your app. by passing an object as a parameter to next, express knows there is an error to handle. Express immediately stops

app.use((req, res, next) => {
  console.log('hello');
  const err = new Error('Oh fuh');
  next(err);
});






ERROR HANDLING MIDDLEWARE

(err, req, res, next) => {}

when an object is passed into the next call, express jumps to the first middleware it can find with four parameters.


app.js

app.use((req, res, next) => {
  console.log('hello');
  const err = new Error('Oh fuh');
  err.status = 500;
  next(err);
});

app.use((err, req, res, next) => {
  res.locals.error = err;
  res.status(err.status);
  res.render('error');
});
//an error object is passed to next(), so express stops. the second middleware is our error handler. It receives the error object as a local, the response's status is set to the error status (this way it appears in devtools under network), and the error.pug template is rendered


error.pug

extends layout

block content
    h1= error.message
    h2= error.status
    pre= error.stack
// message is defined when the error object is declared. status is a property of the error. error's stack property is the "stack trace" that is returned by express






HANDLING 404 ERRORS

when an app gets a request, it will go from one app method call to the next looking for a match. if it gets to the end without finding a route and there are no errors, express's native handler will send a 404 back to the client with some plain text.

app.use((req, res, next) => {
  const err = new Error('not found');
  err.status = 404;
  next(err);
});

//This goes near the bottom of app.js, after all the app.get and app.post middleware, but before our error handler.
















PARAMETERS, QUERY STRINGS, AND MODULARIZING ROUTES

MODULAR ROUTES

A router is kind of like a mini app in Express - you can add middleware and routes to it.

express.Router() creates an object that behaves similarly to the app object.

convention to separate routes into their own file (./routes/index.js)

ex:

const express = require('express');
const router = express.Router();

router.get('/cards', (req, res) => {
  res.locals.prompt = "Who is buried in Grant's tomb?";
  res.render('card');
});
...
...

module.exports = router;

// /index.js is optional, as it is default to select the index file.


APP.JS

const routes = require('./routes/index.js');

app.use(routes);

// If there is more than one routes file, app.use will have a path as a first argument

const mainRoutes = require('./routes/index.js');
const cardroutes = require('./routes/cards');

app.use(mainRoutes);
app.use('/cards', cardRoutes);

./ROUTES/CARDS.JS

const express = require('express');
const router = express.Router();

router.get('/', (req, res) => {
  res.locals.prompt = "Who is buried in Grant's tomb?";
  res.render('card');
});

module.exports = router;

// "Because we're directing traffic into this file from the cards path in the app.js file, every route in this file would start with "cards". So I can just cut out "cards" (from router.get('/cards',..) ) for now."






USING DATA AND ROUTE PARAMETERS

"You can also include JSON directly in Node. It reads the text file and then parses the text and converts it into a JSON object so you don't have to call json.parse."

create a folder called data to store our local data, and a file called flashcardData.json which includes an object with all our info.

./ROUTES/CARDS.JS

const data = require('../data/flashcardData.json').data;
const cards = data.cards;

router.get('/', (req, res) => {
  res.locals.prompt = cards[0].question;
  res.locals.hint = cards[0].hint;
  res.render('card');
});


A route parameter is a variable that a user can put right into the URL to point to a particular resource

./ROUTES/CARDS.JS

router.get('/:id', (req, res) => {
  res.locals.prompt = cards[req.params.id].question;
  res.locals.hint = cards[req.params.id].hint;
  res.render('card');
});

// "use a colon to tell express to treat this part of the url as a variable", can be named anything
// Whatever we put in the url will then be put in the place where req.params.id is









If you have an app with "birds" routes declared this way:
const birds = require('./birds');
app.use('/birds', birds);

and there is the following route in the birds file:
router.get('/south-american', (req, res) => {
  ...
}

what URL would match the route above?

/birds/south-american






CARD TEMPLATE

"checking for a query string is very similar to checking for a route parameter or a cookie. if a query string is in a request, it will be in the request object under the query property."

./ROUTES/CARDS.JS

router.get('/:id', (req, res) => {
  const { side } = req.query;
  const { id } = req.params;
  const text = cards[id][side];
  const { hint } = cards[id];

  const templateData = { text, hint };
  res.render('card', templateData);
});

// this uses an ES6 feature called destructuring (const side = req.query.side vs the way it is, or const templateData = { text: text, hint: hint })
// the url will look like "http://localhost:3000/cards/0?side=question", so the side variable will be question or answer. the text is the question/answer property of the card in the json file. templateData is passed to render as a local, so it has access to the text and hint data. (same as res.locals.templateData = templateData).

./VIEWS/CARD.PUG

extends layout.pug

block content
  section#content
    h2= text
    if hint
      p
        i Hint: #{hint}

// change h2 to render the text variable (which will be the question/answer property of the card object in our json file), instead of prompt (which was previously passed as a local as an object, res.locals.prompt = "Who's buried in Dave's tomb?")






ADDING LINKS

router.get('/:id', (req, res) => {
  const { side } = req.query;
  const { id } = req.params;
  const text = cards[id][side];
  const { hint } = cards[id];

  const templateData = { text };

  if (side === 'question') {
      templateData.hint = hint;
  }
  
  res.render('card', templateData);
});

// template data only holds the hint variable when the side is "question"



./VIEWS/CARD.PUG

extends layout.pug

block content
  section#content
    h2= text
    if hint
      p
        i Hint: #{hint}
    a(href=`${id}?side=${sideToShow}`)= sideToShow

// add link to other side. href is /0?side=answer, /cards is assumed. sideToShow is defined in the get request and added as a local


./ROUTES/CARDS.JS

router.get('/:id', (req, res) => {
  const { side } = req.query;
  const { id } = req.params;
  const text = cards[id][side];
  const { hint } = cards[id];

  const templateData = { id, text };

  if (side === 'question') {
    templateData.hint = hint;
    templateData.sideToShow = 'answer';
  } else if (side === 'answer') {
    templateData.sideToShow = 'question';
  }

  res.render('card', templateData);
});

// if side is question, pass answer as the sideToShow, which will be added to the "question" link in the pug template






RANDOMIZE CARDS

./ROUTES/CARDS.JS

router.get('/', (req, res) => {
  const numberOfCards = cards.length;
  const flashcardId = Math.floor(Math.random() * numberOfCards);
  res.redirect(`/cards/${flashcardId}?side=question`);
});

// we don't need to start the route with /cards, it's implied. when we go to /cards, we're redirected to a random card.


if we go to /cards/3, a mostly blank page shows. we need a query string in order to render the appropriate page.

./ROUTES/CARDS.JS

router.get('/:id', (req, res) => {
  const { side } = req.query;
  const { id } = req.params;

  if (!side) {
    return res.redirect(`/cards/${id}?side=question`);
  }

  const text = cards[id][side];
  const { hint } = cards[id];

  const templateData = { id, text };

  if (side === 'question') {
    templateData.hint = hint;
    templateData.sideToShow = 'answer';
  } else if (side === 'answer') {
    templateData.sideToShow = 'question';
  }

  res.render('card', templateData);
});

// if the url doesn't contain a query string, we're redirected to the same url but with a query string added. we need to "return" so that the rest of the get request doesn't render



LINKING AROUND THE APPLICATION

./VIEWS/CARD.PUG

extends layout.pug

block content
  section#content
    h2= text
    if hint
      p
        i Hint: #{hint}
    a(href=`${id}?side=${sideToShow}`)= sideToShow
    br
    a(href='/cards') next card

// add a link to display the next card


.VIEWS/INDEX.PUG

extends layout.pug

block content
  section#content
    h2 Welcome, #{name}!
    form(action='/goodbye', method='post')
      button(type='submit') Goodbye
    p
      a(href='/cards') Begin!

// add a link to the flashcards


The greeting and goodbye button are not displayed on all pages. To change this, move the code from the index.pug file to the layout.pug file.

./VIEWS/LAYOUT.PUG

doctype html
html(lang="en")
  head
    title Flashcards
  body
    include includes/header.pug
    if name
      h2 Welcome, #{name}!
      form(action='/goodbye', method='post')
        button(type='submit') Goodbye
    block content
    include includes/footer.pug

// if a name cookie doesn't exist, then the welcome and goodbye button are not displayed.

./ROUTES/CARDS.JS

router.get('/:id', (req, res) => {
  const { side } = req.query;
  const { id } = req.params;

  if (!side) {
    return res.redirect(`/cards/${id}?side=question`);
  }

  const name = req.cookies.username;
  const text = cards[id][side];
  const { hint } = cards[id];

  const templateData = { id, text, name };

  if (side === 'question') {
    templateData.hint = hint;
    templateData.sideToShow = 'answer';
  } else if (side === 'answer') {
    templateData.sideToShow = 'question';
  }

  res.render('card', templateData);
});

// give the layout access to "name", it needs to be added as a local. we define name, pass it to template data, and template data is passed to render as a local.
















SERVING STATIC FILES IN EXPRESS

WHAT ARE STATIC ASSETS?

assets that don't need to be rendered/interpreted, but just passed to the browser.






ADDING STATIC ASSETS TO THE APP

https://expressjs.com/en/starter/static-files.html
https://expressjs.com/en/4x/api.html#express.static

the name public is commonly used for the folder containing static assets

we need to add static middleware to app.js in order to serve the static assets.

APP.JS

app.use('/static', express.static('public'));

// we add "/static" to route the static server to a specific location. This is in case any file names within the "public" folder conflict with other routes.

to find the css file in the browser, we can just go to http://localhost:3000/static/stylesheets/style.css - express will make the public folder contents available from the root of the app.


next we need to link the HTML our app produces to this file. Since we want to make all the styles available to the pages in our application, the best place to link to the style sheets will be in the template layout.

/VIEWS/LAYOUT.PUG

doctype html
html(lang="en")
  head
    title Flashcards
    link(rel='stylesheet', href='static/stylesheets/style.css')
  body
    include includes/header.pug
    if name
      h2 Welcome, #{name}!
      form(action='/goodbye', method='post')
        button(type='submit') Goodbye
    block content
    include includes/footer.pug

// when express renders this template, it send the HTML to the browser, the browser will see the link tag and make a request to the stylesheets/style.css. because we set up a static server, the public folder's contents is at /static. Any path in the folder will automatically be available to static.






MERGING THE DESIGN FILES























