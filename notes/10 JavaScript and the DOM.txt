THE BROWSER ENVIRONMENT

WELCOME AND OVERVIEW

DOM = document object model





THINKING GLOBALLY

"alert()" and "location.href" are examples of variables in the browser's global environment. global variables are actually properties of a single global object, which in browsers is called "window" All these properties are controls the browser gives you with javascript. All these globals are properties on the window object

next let's look at another property of window. this object and some of its properties are what we'll focus on for the rest of this course. it's called the document object, and you can use it to select and control elements of the currently loaded webpage 

document.getElementById('myHeading').style.color = 'purple'

we used the getElementById method on the document to select the h1 element with the id "myHeading" then we changed its CSS color property to purple. We selected the element then manipulated it.





WHAT IS THE DOM?

the document is a global object representing the html and content of a webpage. with javascript you can select and change different parts of the webpage by interacting with the document. understanding how that works requires an understanding of the dom.

dom is a representation of a webpage that js can use. just like a city map is a model of a city that helps you get around town, the dom is a map of a webpage that js can use. unlike a map, the dom is a live entity, so changes that js makes to the dom alters the webpage. imagine if drawing a street on a map made that street appear in real life! well that's kinda how it works in the browser. the dom represents a webpage as a treelike structure. if you think of an html webpage, you have a head and a body. nested inside those you have other elements. the head contains a title element for example, the body contains heading, paragraph and ul elements to name a few, and a ul element would have li elements inside. these nested elements can all be thought of as a tree. the document element or node would be the root node of the tree, the head and body nodes sprout like branches, leading to other branches. at the top of the tree are leaves, like heading elements or list item nodes. these leaves represent the most deeply nested tags on an html page. in computer science though, these trees are drawn from the top down, more like a family tree. in fact, the relationship between nodes is described in family like terms. the body is the parent of the h1, p, and ul nodes, the li nodes are children of the ul node, and the li nodes are siblings of each other. similarly the head and body are siblings as well.

as you'll see very soon, js is going to use these family relationships and this treelike model to understand and alter the structure of webpages.















GETTING A HANDLE ON THE DOM

A SIMPLE EXAMPLE

const myHeading = document.getElementById('myHeading')

myHeading.addEventListener('click', () => {
  myHeading.style.color = 'red';
});





SELECT A PAGE ELEMENT BY ITS ID

const myHeading = document.getElementById('myHeading');
const myButton = document.getElementById('myButton');

myButton.addEventListener('click', () => {
  myHeading.style.color = "red";
});





SELECT ALL ELEMENTS OF A PARTICULAR TYPE

document.getElementsByTagName()

returns a collection, which is like an array - access an element directly by using its index, or loop over the whole collection to access all of them


const myList = document.getElementsByTagName('li');

for (let i = 0; i < myList.length; i++) {
  myList[i].style.color = 'purple';
}





SELECTING ELEMENTS WITH THE SAME CLASS NAME

document.getElementsByClassName()

const card = document.getElementsByClassName('card');
for (let i = 0; i < card.length; i++) {
  card[i].style.backgroundColor = "yellow";
};





USING CSS QUERIES TO SELECT PAGE ELEMENTS

can use id, tag, class...

document.querySelector()
returns first element that matches

document.querySelectorAll()
returns all matching elements

tag:
document.querySelector('li');

ID:
document.querySelector('#myHeading');

class:
document.querySelector('.error-not-purple')

html attribute:
document.querySelector('[title=label]');





LEARNING MORE

Not all js methods are supported by all browsers. MDN shows browser compatibility in specs. you can search caniuse.com to see which browsers support your search term

these methods use css selectors, including descendant selectors















MAKING CHANGES TO THE DOM

GETTING AND SETTING TEXT WITH TEXTCONTENT AND INNERHTML

Read an html element's text with textContent

let myHeading = document.querySelector('h1');
myHeading.textContent
> "JavaScript and the DOM"


Read everything between an element's opening and closing tag with innerHTML

const p = document.querySelector('p.description');
p.innerHTML = "Blue items:"





CHANGING ELEMENT ATTRIBUTES

Read an attribute with element.attribute

const p = document.querySelector('p.description');
p.title = "List description";





STYLING ELEMENTS

Can set in-line styles on an html element with the style attribute, which overrides styles set with external style sheets.

<div style="background-color:teal;"></div>

Just as we saw with other attributes, in-line styles can be set on an element with the style property.

Element.style.prop

However, unlike most attributes, the style property itself is an object. The properties on the style object represent the various CSS properties we can set.

in the console:

variableName.style

returns all the available style property names (background, border, color...)

p.style.color = 'darkblue'





CREATING NEW DOM ELEMENTS

You can create a new element in javascript with document.createElement('htmlElementName')

ex:
document.createElement('div')

addItemButton.addEventListener('click', () => {
  let li = document.createElement('li');
  li.textContent = addItemInput.value;
});

//upon click, the add item button will create a list item whose text content = what was typed in the input box on the webpage





APPENDING NODES

Appending a node to the DOM is done with the appendChild method

parentElement/node.appendChild(childElementName)

(node vs element: same, but node belongs to the DOM and elements are plain html)


addItemButton.addEventListener('click', () => {
  let li = document.createElement('li');
  li.textContent = addItemInput.value;
  document.querySelector('ul').appendChild(li);
});

//adds a list item (whose text content was entered in the input box on the webpage) to the unordered list in our html





REMOVING NODES

parentElement/Node.removeChild(childElement)

removeItemButton.addEventListener('click', () => {
  let li = document.querySelector('li:last-child');
  document.querySelector('ul').removeChild(li);
});

//removes the last list item from the unordered list. Notice the last-child pseudo selector















RESPONDING TO USER INTERACTION

WHAT IS AN EVENT?

mouse: click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout

tablet: touchstart, touchmove, touchend

keyboard: keydown, keyup, keypress

not tied to user action: load





FUNCTIONS AS PARAMETERS

functions can be treated like any other data type, like a number string or object. for example, you can pass a function as an argument into another function.

function say(something) {
  console.log(something);
}

function exec(func, arg) {
  func(arg);
}

exec(say, "Hi there");

//exec accepts the function say as an argument. "Hi there" is printed to the console



OR

function exec(func, arg) {
  func(arg);
}

exec(function say(something) {
  console.log(something);
}, "Hi there");

//a function can be written directly inside of another function.


OR

function exec(func, arg) {
  func(arg);
}

exec((something) => {
  console.log(something);
}, "Hi there");

//this is the same except written as an anonymous function





DELAYING EXECUTION WITH SETTIMEOUT()

setTimeout() is a method of the window object

window.setTimeout((something) => {
  console.log(something);
}, 3000, "Hi there");

//logs "Hi there" to the console after 3 seconds

the setTimeout method requires a function as its first argument, and expects that the second argument will be the number of milliseconds to delay running said function, and any further arguments are assumed to be parameters of the function





LISTENING FOR EVENTS WITH ADDEVENTLISTENER()

eventObject.addEventListener('event', function)

example:

const listItems = document.getElementsByTagName('li')[0];

listItems.addEventListener('mouseover', () => {
    listItems.textContent = listItems.textContent.toUpperCase();
});

//upon mouseover of first list item, all letters are capitalized






EVENT BUBBLING AND DELEGATION

An event can be triggered by a parent/child and affect the entire lineage?

You can set the event listener on a parent of the target element?

"A parent experiences the same event a child does because of event bubbling"

"clicking a list item also triggers a click event on the ul element containing the list item"

"we can add an event listener to a parent element, and let it handle events on its children. An event listener on an unordered list can handle the click event for any of its children list items."






THE EVENT OBJECT

"An event listener on an unordered list can handle the click event for any of its children list items. But how does the parent know which child triggered the event? When an event handler is called, it receives an event object as its first argument."

EventTarget.addEventListener('click', (event) => {
   //event is an object with info and methods
});

https://developer.mozilla.org/en-US/docs/Web/API/Event

"the property you'll probably use most often is Target, which is a reference to the element that first received the event."

example:

document.addEventListener('click', (event) => {
  console.log(event.target);                          
});

//logs to the console the element that first received the event

example:

const listDiv = document.querySelector('.list');

listDiv.addEventListener('mouseover', (event) => {
  if (event.target.tagName == 'LI') {
    event.target.textContent = event.target.textContent.toUpperCase();
  }
});

//upon mouseover, ONLY list items are changed to all caps. Without the if statement, anything within the Div (including the div) would change to all caps.














TRAVERSING THE DOM

USING PARENTNODE TO TRAVERSE UP THE DOM

"traversal is similar to selection, in that you're obtaining a reference to an element. to get a reference to an element's parent node, you can use the parentNode property"

Element.parentNode

example:

const listUl = listDiv.querySelector('ul');

listUl.addEventListener('click', (event) => {
  if (event.target.tagName == 'BUTTON') {
    let li = event.target.parentNode;
    let ul = li.parentNode;
    ul.removeChild(li);
  }
});

//when a list item's button is clicked, the item is removed. event listener is placed on the ul. if statement means that the handler is only called when the thing being clicked within the ul is a button. parentNode can be used to select the appropriate element based on its relationship to other elements - li is the parent of button, ul is the parent of li







USING PREVIOUSELEMENTSIBLING AND INSERTBEFORE

Element.previousElementSibling

returns previous html element

ex:

li.previousElementSibling

//returns an li object



parentNode.insertBefore(newNode, referenceNode);

parentNode is the parent element, newNode is the element to be inserted, referenceNode is the element that we want our insertion to go before

ex:

listUl.addEventListener('click', (event) => {
  if (event.target.tagName == 'BUTTON') {
    if (event.target.className == 'up') {
      let li = event.target.parentNode;
      let prevLi = li.previousElementSibling;
      let ul = li.parentNode;
      ul.insertBefore(li, prevLi);
    }
  }
});

//event listener on the ul. if the thing clicked is a button, with the class name "up", then the button's associated list item will be moved up the list. insertBefore is called on the ul, and the li is inserted before the previous li.


nextElementSibling also exists and functions the way you'd expect







GETTING ALL CHILDREN OF A NODE WITH CHILDREN

ParentNode.children

returns all children of the parent node


example:

const listUl = listDiv.querySelector('ul');
const lis = listUl.children;

for (let i = 0; i < lis.length; i ++) {
  attachListItemButtons(lis[i]);
};

//loops over all of the children of the ul and attaches buttons (function defined elsewhere)



GETTING THE FIRST AND LAST CHILD

ParentNode.firstElementChild

ParentNode.lastElementChild


example:

const listUl = listDiv.querySelector('ul');
const firstListItem = listUl.firstElementChild;
const lastListItem = listUl.lastElementChild;

firstListItem.style.backgroundColor = 'plum';
lastListItem.style.backgroundColor = 'purple';

//changes the background color of the first and last list items