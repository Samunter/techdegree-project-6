ARRAY ITERATION

JAVASCRIPT ARRAY OVERVIEW

An array is a sequenced collection of data, basically a list of information. sometimes referred to as 'list-like objects'.






'FOR' VS FOREACH()

forEach is a method on any array, just like push or pop. When the method is called, the callback function's first parameter will be the current iterated item in the array.






EXAMPLES USING FOREACH()

const fruits = ['apple', 'pear', 'cherry'];
let capitalizedFruits = []

fruits.forEach(fruit => {
  let capitalizedFruit = fruit.toUpperCase();
  capitalizedFruits.push(capitalizedFruit);
});

> ['APPLE', 'PEAR', 'CHERRY']



const prices = [6.75, 3.10, 4.00, 8.12]; // Total: 21.97
let total = 0;

prices.forEach(price => {
  total += price;
});

> 21.97



const names = ['Selma', 'Ted', 'Mike', 'Sam', 'Sharon', 'Marvin'];
const sNames = [];

names.forEach(name => {
  if (name[0] === "S") {
    sNames.push(name);
  }
});






FOREACH() 'INDEX' AND 'ARRAY' PARAMETERS

The second parameter of the callback function is the current index. The third is the array itself.















ARRAY MANIPULATION

REMOVE ARRAY ITEMS WITH FILTER()

Filter doesn't affect the original array, but returns a new array.

you call filter by passing a callback function into the method, where the first parameter will be the current item from the array. the callback is a function that returns true or false. if it returns true, the item will be added to a new array.

example:

const names = ['Selma', 'Ted', 'Mike', 'Sam', 'Sharon', 'Marvin'];
const startsWithS = name => name.charAt(0) === 'S';
const sNames = names.filter(startsWithS);

>[ 'Selma', 'Sam', 'Sharon' ]

//the callback function here is assigned to a variable instead of being written inline, but either is correct. the callback function returns true or false. the filter method returns a new array, so it can be assigned to a variable which will contain the new array.



const numbers = [1,2,3,4,5];
const no3 = numbers.filter(number => number !== 3);

> [1,2,4,5]



const numbers = [1,2,3,4,5,6,7,8,9,10];
const evens = numbers.filter(number => number % 2 === 0);

>[ 2, 4, 6, 8, 10 ]

//the % is the remainder operator, so number % 2 = the remainder of number / 2. If the number is divisible by 2, the filter method adds the number to the new array.






TRANSFORM ARRAY ITMES WITH MAP()

map transforms each item in an array to something else.

map returns a new array, leaving the original array unchanged.

example:

const strings = ['1','2','3','4','5'];
const numbers = strings.map(string => parseInt(string, 10));

>[1,2,3,4,5]

//parseInt technically takes a second parameter specifying the base of the numbers, but it generally assumes base 10 (unless the string stars with 0, 0x, some other things)



const fruits = ['apple', 'pear', 'cherry'];
const capitalizedFruits = fruits.map(fruit => fruit.toUpperCase());

>['APPLE', 'PEAR', 'CHERRY']



const prices = [5, 4.23, 6.4, 8.09, 3.20];
const priceToDollars = price => `$${price.toFixed(2)}`
const newPrices = prices.map(priceToDollars);

>[ '$5.00', '$4.23', '$6.40', '$8.09', '$3.20' ]

//the callback is stored in a variable here instead of inline, but either is correct
//the callback uses a template literal, which uses backticks instead of quotation marks, and then anything inside of ${} is interpolated and a string is returned, and anything outside of it remains a string.
//the toFixed() method makes the number it's called on return with a fixed number of decimal places, in this case 2.






RETURN SINGLE VALUE FROM AN ARRAY WITH REDUCE()

can return a value from the array, or the result of some operation performed on the array, or information about the array

the callback takes 2 parameters. the first is accumulator, the second represents the current array item. accumulator contains the running total of the value the reduce method returns. the accumulator is what is returned.

the second argument, after the callback, sets the initial value of the accumulator. if a second argument is not provided, the first element of the array will be the inital value.

the callback needs to return a value. arrow functions without {} automatically return a value. otherwise, a return statement is needed.

example:

var total = [0,1,2,3].reduce(
  ( acc, cur ) => acc + cur,
  0
);

// callback has 2 parameters, accumulation and current. method has 2 parameters, callback and initial accumulation.



const prices = [6.75, 3.10, 4.00, 8.12]; // Total: 21.97

const total = prices.reduce((sum, price) => sum + price, 0);

> 21.97



const names = ['Gary', 'Pasan', 'Gabe', 'Treasure', 'Gengis', 'Gladys', 'Tony'];

let gNameCount = names.reduce((count, name) => {
  if (name[0] === "G") {
    return count + 1;    
  } else {
    return count;
  }
}, 0);

> 4

// checks if the current name starts with G. If it does, increase the count by 1. If not, do nothing to the count.















COMBINING ARRAY METHODS

CHAINING ARRAY METHODS

since these array methods return arrays, another method can be chained


const years = [1989, 2015, 2000, 1999, 2013, 1973, 2012];
const displayYears = years
  .filter(year => year > 2000)
  .map(year => year.toString() + " A.D.")

> ["2015 A.D.", "2013 A.D.", "2012 A.D."]




WORKING WITH OBJECTS IN ARRAYS

Arrays can contain any type of js, including an object.

example:

const users = [
  {name: 'Samir', age: 27},
  {name: 'Angela', age: 33},
  {name: 'Beatrice', age: 42}
];

const newUsersObject = users.reduce((usersObject, user) => {
  usersObject[user.name] = user.age;
  return usersObject;
}, {});

> { Samir: 27, Angela: 33, Beatrice: 42 }

//the initial array contains 3 objects. the reduce method takes 2 parameters, the callback and the initialization value, which in this case is an empty object {}. the callback takes 2 parameters, the accumulator, which will be a new object that will be returned, and the current user. to make a new parameter, we use bracket notation and inside the bracket we pass the name of the new parameter, which is the name of the current user.



const authors = [
  { firstName: "Beatrix", lastName: "Potter" },
  { firstName: "Ann", lastName: "Martin" },
  { firstName: "Beverly", lastName: "Cleary" },
  { firstName: "Roald", lastName: "Dahl" },
  { firstName: "Lewis", lastName: "Carroll" }
];

const fullAuthorNames = authors.map(author => author.firstName + " " + author.lastName);

> ["Beatrix Potter", "Ann Martin", "Beverly Cleary", "Roald Dahl", "Lewis Carroll"]

// takes an object and returns a string



 


COMBINING FILTER() AND MAP()

example:

const userNames = ['Samir', 'Angela', 'Beatrice', 'Shaniqua', 'Marvin', 'Sean'];

const sObjects = userNames
  .filter(name => name[0] === 'S')
  .map(name => ({name: name}))

> [{name: 'Samir'}, {name: 'Shaniqua'}, {name:'Sean'}]

//filter returns only names beginning with S. map takes a string a returns an object literal. the object literal needs to be contained within parentheses, otherwise the compiler tries to interpret it as a function.



const users = [
  {name: 'Samir', age: 27},
  {name: 'Angela', age: 33},
  {name: 'Beatrice', age: 42},
  {name: 'Shaniqua', age: 30},
  {name: 'Marvin', age: 23},
  {name: 'Sean', age: 47}
];

const geriatricUsers = users
  .filter(user => user.age >= 30)
  .map(user => user.name);

> ['Angela', 'Beatrice', 'Shaniqua', 'Sean'];

// takes all users at least age 30 and returns their name

COMBINING FILTER() AND REDUCE()

example:

const products = [
  { name: 'hard drive', price: 59.99 },
  { name: 'lighbulbs', price: 2.59 },
  { name: 'paper towels', price: 6.99 },
  { name: 'flatscreen monitor', price: 159.99 },
  { name: 'cable ties', price: 19.99 },
  { name: 'ballpoint pens', price: 4.49 }
];

const highestUnder10 = products
  .filter(product => product.price < 10)
  .reduce((highest, product) => { 
    if (product.price > highest.price) {
      return product;
    }
    return highest;
  });

>{ name: 'paper towels', price: 6.99 }

// use filter to return an array of all items under $10. we don't set an initial value for the reduce method because we want the initial value to be the first item of the array. then we compare the price of the first item with the price of another item, and return the item with the higher price. we've omitted else{} because it's always unnecessary.






NESTED DATA AND ADDITIONAL EXPLORATION

"Flattening" is putting the internal elements all on one level, for example taking an array of arrays and putting all items within 1 array

const movies = [
  ['The Day the Earth Stood Still', 'Superman', 'Ghostbusters'],
  ['Finding Dory'],
  ['Jaws', 'On the Waterfront']
]

const flatMovies = movies.reduce((arr, innerMovies) => [ ...arr, ...innerMovies], [])

OR

const flatMovies = movies
  .reduce((arr, innerMovies) => arr.concat(innerMovies), []);

>['The Day the Earth Stood Still', 'Superman', 'Ghostbusters', 'Finding Dory', 'Jaws', 'On the Waterfront']

//the first iteration, arr is empty and the spread operator returns each of 3 movies to the arr. the second iteration, the spread operator returns each of those 3 moves, then the spread operator returns each movie from the next item in the movies array, etc.
//OR concat adds each array to the accumulator



const users = [
  {
    name: 'Samir',
    age: 27,
    favoriteBooks:[
      {title: 'The Iliad'},
      {title: 'The Brothers Karamazov'}
    ]
  },
  {
    name: 'Angela',
    age: 33,
    favoriteBooks:[
      {title: 'Tenth of December'},
      {title: 'Cloud Atlas'},
      {title: 'One Hundred Years of Solitude'}
    ]
  },
  {
    name: 'Beatrice',
    age: 42,
    favoriteBooks:[
      {title: 'Candide'}
    ]
  }
];

const books = users
  .map(user => user.favoriteBooks.map(book => book.title))
  .reduce((arr, titles) => [...arr, ...titles], []);

>['The Iliad', 'The Brothers Karamazov', 'Tenth of December', 'Cloud Atlas', 'One Hundred Years of Solitude', 'Candide'];

// the first map returns the favorite books array from each user. the second array returns the title of each of those books. then with reduce, we use the spread operator to add each of those titles to the accumulator array.







